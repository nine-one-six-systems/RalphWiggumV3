# Ralph Wiggum Setup

A comprehensive, optimized Ralph Wiggum template combining the canonical methodology with advanced features and Cursor integration.

**Two approaches included:**
- **Bash Loop** (`loop.sh`) - External bash-based loop for autonomous runs
- **Claude Code Plugin** (`/ralph-loop`) - In-session loop with stop hook integration

## What is Ralph Wiggum?

Ralph Wiggum is an AI development methodology that reduces software costs through autonomous iteration. The technique uses:

- **Context efficiency**: One task per iteration keeps context in the "smart zone"
- **Disposable plans**: Regenerate plans rather than salvaging stale state
- **Backpressure**: Tests, builds, and validation gates guide convergence
- **Subagents**: Parallel exploration without polluting main context

## Quick Start

### Choose Your Approach

**Bash Loop** (Recommended for autonomous runs):
- Runs externally via `loop.sh`
- Good for: Overnight runs, CI/CD, unattended execution
- See: [Bash Loop Mode](#bash-loop-mode)

**Claude Code Plugin** (Recommended for interactive development):
- Runs in-session via `/ralph-loop` command
- Good for: Interactive iteration, watching progress, learning
- See: [Claude Code Plugin Mode](#claude-code-plugin-mode)

### 1. Initialize in Your Project

```bash
# Copy this setup to your project
./tools/setup-project.sh /path/to/your/project

# Or manually copy files:
# - loop.sh (for bash loop)
# - PROMPT_*.md files
# - AGENTS.md
# - CLAUDE.md
# - .claude/plugins/ralph-wiggum/ (for plugin)
```

### 2. Configure Your Project

Edit these files with your project-specific values:

- **AGENTS.md** - Add your build/test commands
- **AUDIENCE_JTBD.md** - Define your audience and their jobs (for SLC workflow)
- **PROMPT_plan.md** - Replace `[project-specific goal]` placeholder
- **specs/** - Create spec files for your features (use `specs/_template.md`)

### 3. Create Requirements

```bash
# Create spec files in specs/ directory
# Use specs/_template.md as a starting point
```

### 4. Plan

```bash
# Standard planning
./loop.sh plan

# SLC-oriented planning (requires AUDIENCE_JTBD.md)
./loop.sh plan-slc

# Work-scoped planning (on a feature branch)
git checkout -b ralph/user-auth
./loop.sh plan-work "user authentication system"
```

### 5. Build

```bash
# Build mode with max iterations
./loop.sh 20

# Or unlimited (Ctrl+C to stop)
./loop.sh
```

## File Structure

```
project-root/
├── loop.sh                      # Main orchestrator (4 modes)
├── PROMPT_plan.md               # Standard planning mode
├── PROMPT_plan_slc.md           # SLC-oriented planning
├── PROMPT_plan_work.md          # Work-scoped branch planning
├── PROMPT_build.md              # Building mode
├── AGENTS.md                    # Operational guide (keep <60 lines)
├── IMPLEMENTATION_PLAN.md       # Task list (generated by Ralph)
├── AUDIENCE_JTBD.md             # Audience + Jobs (for SLC workflow)
├── CLAUDE.md                    # Claude Code auto-load config
├── specs/                       # Requirement specs
│   ├── _template.md             # Spec file template
│   └── [your-specs].md          # Your feature specs
├── src/                         # Application source code
│   └── lib/
│       ├── llm-review.ts        # LLM-as-judge fixture
│       └── llm-review.test.ts   # Usage examples
├── .cursor/
│   └── rules/                   # Cursor rules (optional)
│       └── *.mdc                # Your rule files
└── tools/
    ├── check-ralph.sh           # Progress checker
    ├── watch-ralph.sh            # Live monitor
    └── setup-project.sh         # Project initializer
```

## Two Approaches

### Bash Loop Mode

The traditional bash-based approach using `loop.sh`. Runs externally and autonomously.

**When to use:**
- Autonomous overnight runs
- CI/CD integration
- Unattended execution
- Production workflows

**Quick start:**
```bash
./loop.sh plan      # Create plan
./loop.sh 20       # Build (20 iterations)
```

See [Modes](#modes) section below for details.

### Claude Code Plugin Mode

The official Anthropic plugin that runs in-session using a stop hook.

**When to use:**
- Interactive development
- Watching progress in real-time
- Learning how Ralph works
- Quick iterative fixes

**Quick start:**
```bash
# In Claude Code:
/ralph-loop "Build a REST API for todos" --completion-promise "DONE" --max-iterations 20

# Cancel if needed:
/cancel-ralph
```

**How it works:**
1. Creates `.claude/ralph-loop.local.md` state file
2. You work on the task
3. When you try to exit, stop hook intercepts
4. Same prompt fed back automatically
5. You see your previous work in files
6. Continues until completion promise detected or max iterations

**Completion promise:**
To signal completion, output:
```
<promise>DONE</promise>
```

The plugin is located at `.claude/plugins/ralph-wiggum/` and is automatically loaded by Claude Code.

**Plugin commands:**
- `/ralph-loop <PROMPT> [--max-iterations N] [--completion-promise TEXT]` - Start loop
- `/cancel-ralph` - Cancel active loop
- `/help` - Get help on Ralph commands

See the [plugin README](.claude/plugins/ralph-wiggum/README.md) for detailed documentation.

## Modes

### Build Mode

Implements tasks from `IMPLEMENTATION_PLAN.md` one at a time.

```bash
./loop.sh          # Unlimited iterations
./loop.sh 20       # Max 20 iterations
```

**What it does:**
1. Reads `IMPLEMENTATION_PLAN.md`
2. Picks highest-priority incomplete task
3. Implements it completely
4. Runs validation (tests, typecheck, lint)
5. Commits if tests pass
6. Updates plan
7. Exits → fresh context for next iteration

### Plan Mode

Generates or updates `IMPLEMENTATION_PLAN.md` through gap analysis.

```bash
./loop.sh plan         # Unlimited iterations
./loop.sh plan 5       # Max 5 iterations
```

**What it does:**
1. Studies `specs/*` and existing code
2. Compares specs vs code (gap analysis)
3. Derives test requirements from acceptance criteria
4. Creates prioritized task list
5. No implementation, no commits

### Plan-SLC Mode

SLC-oriented planning that recommends Simple, Lovable, Complete releases.

```bash
./loop.sh plan-slc
```

**Requirements:**
- `AUDIENCE_JTBD.md` must exist
- Specs should be activity-oriented (not capability-oriented)

**What it does:**
1. Studies audience and their JTBDs
2. Sequences activities into user journey map
3. Recommends next SLC release slice
4. Plans tasks scoped to that slice

### Plan-Work Mode

Creates a scoped plan for a work branch.

```bash
git checkout -b ralph/user-auth
./loop.sh plan-work "user authentication system with OAuth"
```

**What it does:**
1. Creates focused `IMPLEMENTATION_PLAN.md` for work scope
2. Conservative scoping (excludes uncertain tasks)
3. Can be regenerated if too narrow

**Important:** Run on a work branch, not main/master.

## Core Principles

### Context Is Everything

- ~176K usable tokens from 200K window
- 40-60% utilization = "smart zone"
- One task per loop = 100% smart zone utilization
- Use subagents for expensive exploration

### Plans Are Disposable

- Plans drift, requirements change
- Regeneration cost: one Planning loop
- Fighting stale plans wastes iterations
- When wrong: delete and regenerate

### Backpressure Beats Direction

Three layers:

1. **Downstream gates**: Tests, typecheck, lint, build
2. **Upstream steering**: Existing code patterns guide approach
3. **LLM-as-judge**: For subjective criteria (tone, aesthetics, UX)

Start with hard gates (tests/builds), add LLM-as-judge for subjective criteria.

## Advanced Features

### Acceptance-Driven Backpressure

Tests are derived from acceptance criteria during planning. This creates a direct line from "what success looks like" to "what verifies it."

**Benefits:**
- Prevents "cheating" (can't claim done without required tests)
- Enables TDD workflow
- Clear completion signal
- Maintains determinism

### LLM-as-Judge

For subjective criteria that resist programmatic validation:

- Creative quality (tone, narrative flow)
- Aesthetic judgments (visual harmony, design balance)
- UX quality (intuitive navigation, clear hierarchy)
- Content appropriateness (context-aware messaging)

**Usage:**
```typescript
import { createReview } from "@/lib/llm-review";

// Text evaluation
const result = await createReview({
  criteria: "Message uses warm, conversational tone",
  artifact: "Welcome to our platform!",
});

// Vision evaluation
const result = await createReview({
  criteria: "Layout demonstrates clear visual hierarchy",
  artifact: "./tmp/dashboard.png",
  intelligence: "smart", // For complex judgments
});
```

Ralph discovers this pattern from `src/lib/llm-review.test.ts` examples.

### SLC Releases

Simple, Lovable, Complete releases instead of MVPs:

- **Simple**: Narrow scope, ship fast
- **Lovable**: People actually want to use it
- **Complete**: Fully accomplishes a job, not broken preview

**Workflow:**
1. Define audience and JTBDs → `AUDIENCE_JTBD.md`
2. Define activities → `specs/*.md` (one per activity)
3. Plan SLC slice → `./loop.sh plan-slc`
4. Build slice → `./loop.sh`

### Work-Scoped Branches

Scoped planning at branch creation (deterministic) rather than runtime filtering (probabilistic).

**Workflow:**
```bash
# 1. Create work branch
git checkout -b ralph/user-auth

# 2. Create scoped plan
./loop.sh plan-work "user authentication system"

# 3. Build from scoped plan
./loop.sh 20
```

## Monitoring

### Check Progress

```bash
./tools/check-ralph.sh
```

Shows:
- Task completion status
- Git status and recent commits
- Ralph process status
- Log file summary

### Watch Live

```bash
./tools/watch-ralph.sh        # 5 second refresh
./tools/watch-ralph.sh 10     # 10 second refresh
```

Auto-refreshing display with:
- Progress percentage
- Real-time build status
- Recent commits
- Process status

## Tips

### Starting Out

1. **Start small** - Begin with 3-5 tasks, not 50
2. **Clear acceptance criteria** - Vague specs = vague output
3. **Watch first few iterations** - Adjust prompts if Ralph goes off-track
4. **Rules are steering** - If output quality is wrong, tune the rules

### When Things Go Wrong

- **Plan is stale** → Regenerate: `./loop.sh plan`
- **Ralph going in circles** → Add guardrails to prompt
- **Wrong patterns** → Add/update utilities in `src/lib/`
- **Tests failing** → Check backpressure commands in `AGENTS.md`

### Best Practices

- Keep `AGENTS.md` under 60 lines
- One spec file per topic (use "one sentence without 'and'" test)
- Let Ralph discover patterns from code, not exhaustive prompts
- Trust eventual consistency through iteration

## Troubleshooting

### Loop Won't Start

- Check `claude` CLI is installed: `which claude`
- Verify prompt file exists: `ls PROMPT_*.md`
- Check file permissions: `chmod +x loop.sh`

### Ralph Not Committing

- Check git is initialized: `git status`
- Verify tests are passing: Run validation commands manually
- Check for completion signal: `grep ALL_TASKS_COMPLETE ralph.log`

### Plan Seems Wrong

- Regenerate: `./loop.sh plan`
- Check specs are clear: Review `specs/*.md`
- Verify gap analysis: Compare specs to actual code

## Comparison: Bash Loop vs Plugin

| Aspect | Bash Loop (`loop.sh`) | Claude Code Plugin (`/ralph-loop`) |
|--------|----------------------|-----------------------------------|
| **Execution** | External bash script | In-session stop hook |
| **Context** | Fresh each iteration | Persistent session context |
| **Best for** | Autonomous runs, CI/CD | Interactive development |
| **Monitoring** | Log files, git commits | Real-time in session |
| **Control** | Ctrl+C, max iterations | `/cancel-ralph`, max iterations |
| **Setup** | Requires `loop.sh` | Plugin auto-loaded |
| **Modes** | plan, plan-slc, plan-work, build | Single prompt-based loop |
| **Integration** | Works with all prompts | Works with any prompt |

**Recommendation:**
- Use **bash loop** for production workflows and autonomous execution
- Use **plugin** for interactive development and learning

Both approaches can coexist - use whichever fits your workflow!

## Resources

- [Original Playbook](https://github.com/ghuntley/how-to-ralph-wiggum) - Geoffrey Huntley's fork
- [Clayton Farr's Documentation](https://github.com/ClaytonFarr/ralph-playbook) - Original playbook
- [Official Plugin](https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum) - Anthropic's Claude Code plugin
- [Ralph Coin](https://ralphcoin.org) - Community resources

## License

This setup is provided as-is for use in your projects. The Ralph Wiggum methodology is open and community-driven.
